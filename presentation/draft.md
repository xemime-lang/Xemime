**では発表致します。**

**突然ですが、言語処理系、というキーワードを, ご存知でしょうか。**  
**これは、ある言語を処理して、何らかの動作を行うものの総称です。**  
具体的には、ソースコードを即座に実行する, インタプリタ、  
中間言語や機械語に変換して 実行ファイルを出力する, コンパイラ、  
別のプログラミング言語のソースコードに変換する, トランスパイラなどが含まれます。

私は、Kotlin, という、JVM上で動作する、Javaと互換性を持つプログラミング言語に、  
以前から興味を惹かれていました。冗長になりやすいJavaのソースコードが、まさにイマドキのスクリプト言語で書いたような短くて読みやすいものに生まれ変わるのが非常に魅力的に感じられました。
今回、私は様々なプログラミング言語の特徴を参考にしながら、オリジナルのプログラミング言語を設計し、そのインタプリタを開発しました。
それが「Xemime」です。

これから、ソースコードが実行されるまでの流れと、主な言語仕様を紹介いたします。

ついでながら、XemimeのリファレンスをこちらのURLで公開しています。
また、ブラウザ上でソースコードをテキストエリアに入力し、ボタン一つで実行できるオンライン実行環境、「tryXemime」を併せて公開しています。
発表後にご覧いただければ幸いです。

申し遅れましたが、私は高知県にある土佐塾高等学校からやってきました、松本幸大といいます。
普段はVPSを使ってWebサーバーを構築したり、Webアプリを配信したりしています。
0918nobita、というハンドルネームでGitHub等で活動しています。

さて、ソースコードが実行されるまでの流れについてですが、まず最初に、ソースコードを文法要素ごとに切り分ける字句解析を行います。
この処理を担当するプログラムを「レキサ」といいます。
その後、構文に従って単語が並んでいるかを確かめ、構文木と呼ばれるデータを出力する構文解析を行います。
この処理を担当するプログラムを「パーサ」といいます。
最後に、ソースコード中に記述されているシンボルの参照を明らかにし、データ型の整合性がとれているかを確認する意味解析を行い、後述するrunメソッドを呼び出して実行します。
パーサ関連の仕様について紹介致します。
Xemimeインタプリタに含まれるパーサでは、再帰下降型構文解析という手法を採用しています。
最近ではANTLRやJavaCC, yaccなどの、パーサジェネレータと呼ばれる外部ライブラリを使用して、構文定義を記述したファイルを用意するだけで、パーサ自体が自動生成されるような環境を整えるのが、主流となっています。
しかし、今回は初めて言語処理系の実装に挑戦するので、再帰下降型パーサのロジックを理解するために、あえて先程挙げたような外部ライブラリを、一切使用していません。

レキサとパーサの両方で、「ノード」というデータ構造を用いて文法要素を処理しています。
これは、runメソッドを呼び出すことで実行が可能なオブジェクトです。
子要素として他のノードを取り込むことができ、runメソッドを呼び出されたときに子要素の実行結果に応じで挙動を変えることができます。
Xemimeのインタプリタでは、字句解析、構文解析、意味解析の３段階の処理を通じて、たくさんのノードを子要素として包括する大きなたった一つのノードを生成します。
そのrunメソッドを呼び出すことで、連鎖的に子要素のrunメソッドが呼び出されて評価が進んでいき、実行が完了します。

Xemimeの文法に関する主な仕様を紹介いたします。
一般的なプログラミング言語と同じように四則演算ができ、関数呼び出しについては閉じ括弧が行末に来る場合に限り、糖衣構文を利用することができます。
引数を2つ取る関数なら、バッククォートでシンボルを挟み込んで2項演算子として動作させることもでき、これを中置関数とよんでいます。
関数定義については、ご覧の通りです。
ラムダ式も実装しています。
先程紹介したfnから始まる関数定義とは違い、呼び出し部分より後ろに定義を記述する、いわゆる「関数定義の巻き上げ」はできません。

では、実際のソースコードとその実行結果で確認しながら、説明いたします。

画面中央のソースコードをご覧ください。
会場にいらっしゃるみなさんはすでにご承知のこととは存じますが、一般的な言語と同じくlet命令を使用して変数を宣言しています。
関数定義の巻き上げを実装しており、ここではadd関数の定義は11行目以降にありますが、1行目で呼び出すことができます。
解析中に、グローバル環境を含めた各スコープで、関数定義を表すノードだけを、そのスコープの先頭に移動して、最初に実行されるようにすることで実現しました。
4行目から9行目では、for文とif文を組み合わせて、2から10までの2の倍数を、スペース区切りで出力させています。

画面を切り替えます。

let文では、変数名の後ろで型を指定することができます。
明示的に型が指定されているにも関わらず、初期値の型と一致していない場合、意味解析の段階でエラーを発生させます。
ここではInt型の配列を宣言・初期化しています。
5行目ではラムダ式を使用して、２数の和を返す関数オブジェクトを生成しています。
plusというシンボルの後ろに括弧と引数リストを記述して呼び出すこともできますが、２つ取るため中置関数に変換して扱っています。
後半では、while文を使用して、2から20までの2の倍数を、括弧区切りで出力させています。
事前に用意された変数iをカウンタとして、インクリメント演算子を使用してその値を1ずつ増加させながらループを続け、いずれはこのwhile文の、「変数iの値は10以下である」という条件を満たさなくなり、すべての処理が終了します。

画面を元に戻します。

今後は、既存のオブジェクトシステムと型システムを改善し、セルフホスティングされた型推論のある動的型付け言語を目指して、オープンソースで開発を続けて行きます。
また、いずれはコンパイラ基盤のLLVMのフロントエンドとして実装し、実用性と生産性の高い言語に進化させていきたいと思います。

以上で、プレゼンを終了します。ご清聴ありがとうございました。
